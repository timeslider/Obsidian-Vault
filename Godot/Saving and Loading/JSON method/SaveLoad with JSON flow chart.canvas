{
	"nodes":[
		{"id":"afdafb8d30a3faa7","type":"text","text":"# Save manager\n---\nsave_game()\nThe main idea here is to have everything that is going to get saved be in a group called persist. Then use:\n```gdscript\nget_tree().call_group(\"persist\", \"on_save_game\", saved_data)\n```\n\nThat give a function variable called `saved_data` to each persist object in the game. They then write their data to the variable and later we store all these into a file.\n\n","x":-820,"y":-220,"width":860,"height":400},
		{"id":"a33f6b498f27bb2f","x":-820,"y":260,"width":860,"height":1440,"type":"text","text":"# save_manager.gd\n---\n```gdscript\nextends Node\n\n\nvar label_confirmation = preload(\"uid://cm55f7vqlfjre\") # save_load_confirmation\n\nfunc save_game():\n\tvar save_file = FileAccess.open(\"user://save_game2.json\", FileAccess.WRITE)\n\tvar saved_data: Dictionary = {}\n\t\n\t# This calls the on_save_game function inside every persist node and gives\n\t# them a piece of paper called saved_data so they can write either data to it\n\tawait get_tree().call_group(\"persist\", \"on_save_game\", saved_data)\n\n\t# Then we turn that data into a valid JSON string and save it to file\n\tvar json_string = JSON.stringify(saved_data)\n\tsave_file.store_line(json_string)\n\n\nfunc load_game():\n\t# Check if file exists\n\tif not FileAccess.file_exists(\"user://save_game2.json\"):\n\t\tprint(\"no save file found.\")\n\t\treturn\n\t\n\tvar save_file = FileAccess.open(\"user://save_game2.json\", FileAccess.READ)\n\tvar save_nodes = get_tree().get_nodes_in_group(\"persist\")\n\n\tvar json_string = save_file.get_line()\n\tvar node_data = JSON.parse_string(json_string)\n\t\n\tif node_data == null:\n\t\tprint(\"JSON parse error: \", json_string)\n\t\treturn\n\tprint(node_data)\n\t# Loading is just one line of code. We get the data from node_data\n\t# using the uuid. The on_load_game function inside each persist node handles\n\t# It's own loading.\n\tfor node in save_nodes:\n\t\tvar key = str(node.uuid)\n\t\tif node_data.has(key):\n\t\t\tnode.on_load_game(node_data[key])\n\t\telse:\n\t\t\tprint(\"No data for UUID: %s\" % key)\n\n\nfunc _input(event: InputEvent) -> void:\n\tif Input.is_action_just_pressed(\"save\"):\n\t\tsave_game()\n\t\tvar instance = label_confirmation.instantiate() as SaveLoadConfirmation\n\t\tinstance.set_new_text(\"Data saved! (Also, I miss my Mimi ðŸ˜­)\")\n\t\tinstance.position = Vector2(364, 249)\n\t\tadd_child(instance)\n\t\t\n\tif Input.is_action_just_pressed(\"load\"):\n\t\tvar instance = label_confirmation.instantiate() as SaveLoadConfirmation\n\t\tinstance.set_new_text(\"Data loaded! (Also, I miss my Mimi ðŸ˜­)\")\n\t\tinstance.position = Vector2(364, 249)\n\t\tadd_child(instance)\n\t\tload_game()\n```"},
		{"id":"72bc348e7b552b5f","x":-2120,"y":320,"width":840,"height":880,"type":"text","text":"# game_manager.gd\n---\n```gdscript\nextends Node\n\n# Change this each new version\nvar version: String = \"0.0.0\"\n\n# The interal variable that keeps track of the current id\nvar _id: int = -1\n\n# This object's unique id\nvar uuid: String = \"0\" # Set in the ready function\n\n\nfunc _ready() -> void:\n\tself.add_to_group(\"persist\")\n\n\n# Anything in the persist group must have an on_save_game function\nfunc on_save_game(saved_data: Dictionary) -> void:\n\t# saved_data is like a clipboard with every object's persistant data written to it\n\tvar my_data: Dictionary = {}\n\t\n\t# This object just writes it's version number... for now :D\n\tmy_data[\"version\"] = version\n\t\n\t# It's saved into save_data by its uuid for fast retrival later\n\tsaved_data[uuid] = my_data\n\n\n# Anything in the persist group must have an on_load_game function\nfunc on_load_game(saved_data: Dictionary) -> void:\n\tversion = saved_data[\"version\"]\n\n```"},
		{"id":"ac46074821310f5c","x":-2120,"y":-160,"width":840,"height":420,"type":"text","text":"# Game manager\n---\nThis game manager just has saving and loading implemented but otherwise, it doesn't do much at the moment."},
		{"id":"1b3c219a082d3df3","x":-1610,"y":2080,"width":980,"height":1620,"type":"text","text":"# Example persistent object\n---\n```gdscript\nextends Control\n\n@onready var button: Button = $Button\n\n# Unique key for this object\n@export var uuid: String = \"\"\n\n\n# How many times the button has been clicked\nvar count: int = 0:\n\tset(value):\n\t\tcount = value\n\t\tbutton.text = str(count)\nvar color: Color: # Default color\n\tset(value):\n\t\tcolor = value\n\t\tmodulate = value\n\n#var saved_data = SaveableObject.new()\n\n\n\nfunc _ready() -> void:\n\tbutton.pressed.connect(_increment)\n\t#uuid = GameManager.get_new_id()\n\tcolor = modulate\n\n\n#region Save/Load contracts\nfunc on_save_game(saved_data: Dictionary) -> void:\n\t# This condition, if applicable, is checked to see if this data can be saved or not\n\t# It might be a state that doesn't allow it to be saved. For example, \n\t# in the middle of dying or not yet unlocked.\n\t#if condition == true:\n\t\t#return\n\t# simulate a bottle neck to test await\n\tvar i: int = 0\n\twhile i < 1_000_000_00:\n\t\ti += 1\n\tvar my_data: Dictionary = {}\n\tmy_data[\"count\"] = count\n\tmy_data[\"color\"] = { \"r\" : color.r, \"g\" : color.g, \"b\" : color.b }\n\tmy_data[\"focused\"] = button.has_focus()\n\tsaved_data[uuid] = my_data\n\t\n\t# This is bad! It creats a new pointer to my_data so when the function ends\n\t# The connection breaks\n\t#saved_data = my_data \n\n\nfunc on_before_load_game():\n\tpass\n\n\nfunc on_load_game(saved_data: Dictionary):\n\tcount = saved_data[\"count\"]\n\tcolor = Color(saved_data[\"color\"][\"r\"], saved_data[\"color\"][\"g\"], saved_data[\"color\"][\"b\"])\n\tif saved_data[\"focused\"] == true:\n\t\tbutton.grab_focus()\n#endregion\n\n\nfunc _increment() -> void:\n\tcount += 1\n\tbutton.text = str(count)\n\tcolor = Color(randf(), randf(), randf())\n```"},
		{"id":"8b479172cdea3078","x":-390,"y":2080,"width":980,"height":1080,"type":"text","text":"# Persistent object\n---\nThere are a few important things to note here.\n\nFirst, every persistent object must have a\n```gdscript\n@export var uuid: String = \"\"\n```\n\nThis is a unique id for every static object in the game.\n\nIt must also implement `on_save_game`, `on_before_load_game` and `on_load_game`. `On_save_game` is given a `saved_data` dictionary by the save_manager. It then writes all its data to it using the uuid as a key for the dictionary. It also checked an optional condition within its scipt to see if it can be saved or not.\n\n```gdscript\nfunc on_save_game(saved_data: Dictionary) -> void:\n\tif condition == true:\n\t\treturn\n\t\n\tvar my_data: Dictionary = {}\n\tmy_data[\"var_1\"] = var_1\n\tmy_data[\"var_2\"] = { \"r\" : color.r, \"g\" : color.g, \"b\" : color.b }\n\tmy_data[\"var_3\"] = button.has_focus()\n\tsaved_data[uuid] = my_data\n```\n\n\n"}
	],
	"edges":[
		{"id":"e5130b07ee56b071","fromNode":"72bc348e7b552b5f","fromSide":"right","toNode":"a33f6b498f27bb2f","toSide":"left","fromEnd":"arrow"},
		{"id":"c5fac37d009f2a7b","fromNode":"1b3c219a082d3df3","fromSide":"top","toNode":"a33f6b498f27bb2f","toSide":"bottom","fromEnd":"arrow"}
	]
}